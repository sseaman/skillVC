{
  "name": "skillvc",
  "version": "0.2.0",
  "description": "A View / Controller (no Model) framework for quickly creating custom skills",
  "main": "index.js",
  "directories": {
    "doc": "docs",
    "lib": "lib",
    "test": "test"
  },
  "dependencies": {
    "handlebars": "^4.0.5",
    "deep-extend": "^0.4.1",
    "winston-simple": "^1.0.2"
  },
  "scripts": {
    "test": "test.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/sseaman/skillVC.git"
  },
  "bugs": {
    "url": "https://github.com/sseaman/skillVC/issues"
  },
  "keywords": [
    "alexa",
    "skill",
    "mvc"
  ],
  "author": {
    "name": "Sloan Seaman"
  },
  "license": "Apache-2.0",
  "readme": "# SkillVC\n\nA View / Controller (no Model) framework for quickly creating complex custom skills for [Alexa](https://developer.amazon.com/alexa). \nChoose either Convention-over-Configuration, Configuration, or Scan approaches to the configuration and execution of your skill.\n\n## Table of Contents\n1. Installation\n2. Source / Webpage\n3. Usage\n    1. Configuration Types\n        1. Convention-over-Configuration\n        2. Scanning\n        3. Congiuration\n    2. SkillVC Context\n    2. Intent Handlers\n    3. Responses\n        1. Handlebars\n    4. Session Handlers\n    5. Filters\n    6. Advanced Configuration\n4. Example\n5. License\n\n## Installation\n-----\nYou can install SkillVC in your project's `node_modules` folder, or you can install it globally.\n\nTo install the latest version available on NPM:\n\n    npm install skillvc\n\nTo install the latest development version:\n\n    npm install git+https://github.com/sseaman/skillVC.git\n\n## Source / Webpage\n-----\nSkillVC is maintained in GitHub.  For full source to to [GitHub SkillVC](https://github.com/sseaman/skillVC)\n\nFor full API documetation, see [SkillVC API docs](https://sseaman.github.io/skillVC/)\n\n## Usage\n-----\nSkillVC is designed to be very easy to use out of the box, but also allow for a high degree of configuration.  Please\nnote that at this time SkillVC only supports **custom** skill types, but this will be expanded if there are enough requests.\n\nFor more detailed documentation, see the individual object API documentation.\n\n### Configuration Types\nSkillVC is designed to be highly configurable and allows for multiple configuration setups as well as providing multiple\npoints to override internal execution to give the most customizable framework possible.  When first starting out\nwith SkillVC you will want to choose the configuration type you want.\n\n#### Convention-over-Configuration\n[Convention-over-Configuration (CoC)](https://en.wikipedia.org/wiki/Convention_over_configuration) is the simpliest and most \nstraightforward way to use SkillVC as objects are simply placed in specific directories and SkillVC does the rest.\n\nTo leverage CoC, first create the following directories in your project:\n* /responses\n* /filters\n* /intents\n* /sessionHandlers\n\nIn each directory you will place the corresponding objects for your skill.  That is, responses go in /responses, objects that handle\nintents go in /intents, and so on. See the individual sections below on how these objects are formatted and their required \nmethods.\n\nOnce you have the objects you want in their correct directories, all that is needed is to have SkillVC \nhandle all of the requests to your skill.  For CoC, with the default directory structure listed above, create an index.js that\nhas the following:\n```\nconst skillVC = require('skillvc').factory.createfromDirectory();\n\nexports.handler = function(event, context) {\n    skillVC.handler(event, context);\n}\n```\n\n#### Scanning\nScanning searches a defined set of files and, based on reading (introspection) each file, classifies them as responses,\nfilters, intents, or sessionHanlder.  Scanning had an advantage over CoC because it allows a single javascript object\nto act as both a filter, intent, and sessionHandler (responses are still required to be separate files).  However, as\neach object must be full loaded and introspected, it can take SkillVC longer to initialize when compared to CoC.\n\nFor Scanning, create an index.js that has the following:\n```\nconst skillVC = require('skillvc').factory.createFromScan([\n    'locationAndNameOfFileToScan',\n    'locationAndNameOfFileToScan',\n    'and so on'\n    ]);\n\nexports.handler = function(event, context) {\n\tskillVC..handler(event, context);\n}\n```\n\n#### Configuration\n-----\nConfiguration is the last built in type and is the most complicated form of initialization.  It provide\nthe most out-of-the-box customization of how SkillVC works and, if done correctly, can be the fastest of the configuration\nmethods. To use configuration, you define a `map ({})` that has the responses, filters, intents, and sessionHandlers and provide that\nmap to SkillVC.  In this way you have complete control over how things are loaded and controlled.\n \nThe map must follow the format and each object must implement the methods required for each object:\n```\n{\n\tsessionHandlers : {\n\t\tstart : [],\n\t\tend : []\n\t},\n\tfilters : {\n\t\tpre : [],\n\t\tpost : []\n\t},\n\tintentHandlers : {},\n\tresponses : {}\n}\n```\n**Note:** This is the same format that the Scanning configuration uses internally when loading objects\n\nFor Configuration, create an index.js that has the following:\n```\nconst skillVC = require('skillvc').factory.createFromConfiguration({\n        the contents of the map to use for configuration\n    });\n\nexports.handler = function(event, context) {\n\tskillVC.handler(event, context);\n}\n```\n\n### SkillVC Context\n-----\nSkillVC uses a contex object (`map`) to store all objects related to execution as well as callbacks for use by the\nvarious objects described below.  The context object, `skillVC` is passed to every object and can be manipulated by\nany object.  This object is used by every object in SkillVC so it's good to know what all is available.\n\nThe context object contains the following:\n* lambda\n    * event - The event that was passed by lambda to your lambda function (index.js)\n    * context - The context that was passed by lambda to your lambda function (index.js)\n* appConfig The configuration that was passed into SkillVC when created.  Specific objects are always present and listed \nbelow.  You can also use this `map` to pass your own objects into SkillVC at time of creation.\n    * responseManager - The ResponseManager that is being used by SkillVC.  This object is used by Intent Handlers\n(or other objects) to get configured responses\n    * filterManager - The FilterManager being used by SkillVC to manage filters\n    * filterChainExecutor - The FilterChainExecutor that will execute the filter chain that has been registered\n    * intentHandlerManager - The IntentHandlerManager being used by SkillVC to manage Intent Handlers\n    * sessionHandlerManager - The SessionHandlerManager being used by SkillVC to manage Session Handlers\n    * logLevel - SkillVC uses [Winston](https://github.com/winstonjs/winston) to internal logging.  See \n[winston-simple](https://github.com/sseaman/winston-simple/) for configuration options\n* appSession - A `map` that is created when SkillVC is initialized, lives for the life of SkillVC, and can be used to\nstore any objects that you want to make avaliable to other objects\n* callback - Has `success` and `failure` functions to be used by Intent Handlers to return Responses and continue SkillVC execution\n* filterChainCallback - Has `success` and `failure` functions to be used by Filters to continue SkillVC execution\n* session - A `map` that is created on every intent event and can be used to store any objects that you want to make\navaliable to other objects\n\n\n### Intent Handlers\n-----\nIntent Handlers are the main objects for your skill and handle requests sent by Alexa to your skill.  When an intent\nis mapped to an utterance by Alexa and then sent to your Lambda function configured with SkillVC, SkillVC will\nexecute the Intent Handler registerd for the executed intent.\n\n#### Mapping to an Intent\nSkillVC can map Alexa intent events to Intent Hanlder objects in a few ways:\n* By list provided from getIntentsList()\n* By Filename\n\n**By list provided from getIntentsList()**\n\nIf the Intent Handler you have created implements the function `getIntentsList()` and returns an array of\nintent names that match the names registered in your intent list in developer.amazon.com/edw, SkillVC will\ninvoke that specific Intent Handler for each of the intents returned byt the function.\n\nExample:\n```\nMyIntentObject.prototype.getIntentsList = function() {\n\treturn ['HelloWorldIntent', 'GoodByeIntent'];\n}\n```\nwould execute MyIntentObject for HelloWorldIntent and GoodByeIntent events\n\n**By Filename**\n\nIf your Intent Handler does not implement `getIntentsList()` then SkillVC will use the name of the file (case sensitive)\nas the intent name.\n\nSo, if you name your file HelloWorldIntent.js, SkillVC will use that object when the HelloWorldIntent event occurs.\n\n#### Executing\nObjects registered as Intent Handlers must implement the `handleIntent(svContext)` function.  The `handleIntent(svContext)`\nfunction will be called for whenever the intent the Intent Handler is registered for is invoked by Alexa.\n\nWhat the `handleIntent(svContext)` method does is entirely up to the developer of the skill, however it must return \na Response via the `callback` method provided by the svContext, even on error.  Failure to invoke the `callback` method will stop\nSkillVC and not allow any downstream filters to execute.\n\nWithin the svContext that is passed to the function are a number of object that can be used by the Intent Handler.  Of \nmost interest to the Intent Handler are the ResponseManager and callback.\n\n**ResponseManager**\n\nThe ResponseManager is SkillVC's object for managing the responses registered with the system.  It allows for retrieval of\nresponses for use by Intent Handlers.  To get the ResponseManager, access `svContext.appConfig.responseManager`.  Once retrieved, \nan Intent Handler can call the `getResponse('someResponseId')` method of the ResponseManager to return the instance of the Response\nthat is required.  See the API documentation for more information and the example below for a common use case.\n\n**callback**\n\nAs Intent Handlers could be preforming async operations, the use of a callback is required to tell SkillVC to continue\nwith its execution flow.  The callback to be used can be accessed in `svContext.callback` and has two methods:\n* `success` - used if the Intent Handler was successful\n* `failure` - used if the Intent Handler had an error or wants to report some other type of issue\n\nThe function used by the skill determines which path down the post intent execution filter chain is used, \n`executePost` or `executePostOnError`.  See the Filter section below for more details\n\nAn example of a simple Intent Handler that uses the above:\n```\nfunction HelloWorldIntentHandler() { }\n\nHelloIntentHandler.prototype.getIntentsList = function() {\n\treturn ['HelloWorldIntent'];\n}\n\nHelloIntentHandler.prototype.handleIntent = function(svContext) {\n\tsvContext.callback.success(svContext.appConfig.responseManager.getResponse('hello').renderTell());\n}\n\nmodule.exports = HelloIntentHandler;\n```\n\n#### Launch Request\nAlexa supports another type of intent event, LaunchRequest, which is executed by Alexa when your skill is invoked\nwithout a specific intent.  An example is when someone says \"Alexa, Tell MySkill\", but does not give a directive.\n\nIn SkillVC, Launch Requests are treated the same as any other intent and are handled by an Intent Handler that maps\nto an intent type of 'launch'.  To register a Intent Handler to execute on Launch Requests you can either:\n* Have `getIntentsList()` return an intent name of 'launch'\n* Name your file launch.js\n\n\n### Responses\n-----\nResponses are defined by individual JSON files (using CoC and Scanning) tha represent the JSON information required by \nAlexa.  To simplify the process of creating a response, SkillVC does not require all Response information, only the fields\nyou are concerned with (all other information will be filled in for you).\n\nTo set any field (or all of them), create a JSON file (or Object if using the Configuration type) with just the fields you want. \n\nExample:\n```\n{\n \t\"outputSpeech\": {\n        \"text\": \"this is some text\"\n    }\n}\n```\n\nThis will create a final Response in SkillVC with:\n```\n{\n    outputSpeech: {\n        type: 'PlainText',\n        text: 'this is some text'\n    },\n    card: {\n        type: 'Simple',\n        title: '',\n        content: ''\n    },\n    reprompt: {\n        outputSpeech: {\n            type: 'PlainText',\n            text: ''\n        }\n    },\n    shouldEndSession: true\n};\n```\n\n#### Response Object\nOnce loaded into SkillVC, the response itself is represented as a Response object.  The Response object \nallows for the continued manipulate of the response as well as the final rendering of the JSON for use by Alexa via the\n`renderAsk()` or `renderTell()` functions of the response.  See the API documentation for more information.\n\n#### Handlebars\nBy default, SkillVC ships with support for using [Handlebars](http://handlebarsjs.com/) in your Responses.  This is provide\nthe ability to do robust variable replacement within a Response.\n\nTo leverage Handlebars in a response, first use the Handlebars [expressions](http://handlebarsjs.com/expressions.html) in your Response:\n```\n{\n \t\"outputSpeech\": {\n\t\t\"text\" : \"{{subject}}. From {{date start}} to {{date end}} at {{location location}}.\"\n\t}\n}\n```\n\nTo do the actual variable replacement, pass a `map` when rendering a response that has the key as the placeholder \n('subject' in the above example) and the value you want to replace it with as the value in the `map`.\n\nSkillVC also supports Handlebars [helpers](http://handlebarsjs.com/block_helpers.html) but allows for full object usage in\nplace of just function support.  This allows your helpers to have more state as well as be more easily externally \nconfigurable.\n\nUsing the 'date' example above, you would create an object that implements Formatter (function format(value)) and register \nit like so:\n```\nvar dateFormat = require('dateformat');\n\nfunction CalendarDateFormatter(options) {\n\tthis._format = \"dddd, mmmm dS, yyyy, h:MM:ss TT\";\n};\n\n/**\n * Required method\n * \n * @param {String} value The value to use in the formatting\n * @return {String} The final formatted string\n */\nCalendarDateFormatter.prototype.format = function(value) {\n\treturn dateFormat(value, this._format);\n};\n```\n\nYou would then register the formatter with the Response:\n```\nresponseManager.getResponse('theResponseIWant').getFormatterManager().addFormatter(\n\t'date' : new CalendarDateFormatter()\n);\n```\n\nWhenever you use the response it will have the formatter registered with it and will use it when doing the variable replacement\nin the response\n\n### Session Handlers\nSession Handlers are objects that can be registered for when a session is opened or closed.  These objects can do\nwhatever the developer chooses and have full access to the svContext.\n\nThe location of the session object provided by Alexa is `svContext.lambda.context.session`.  Also, to allow for additional\noptions, SkillVC provides a new `map` for every skill request at `svContext.session` if developers want \nanother session outside of what Alexa provides.\n\nTo create a Session Handler an object must implement two functions:\n* `sessionStart(svContet)` - Called when a session is started\n* `sessionEnd(svContext)` - Called when a session ends\n\nExample:\n```\nfunction MySessionHandler() {}\n\nMySessionHandler.prototype.sessionStart = function(svContext) {\n\tsvContext.lambda.context.session = {};  // create a new session\n}\n\n// I don't want to do anything..\nMySessionHandler.prototype.sessionEnd = function(svContext) {}\n```\n\n#### Ordering of execution\nSkillVC supports the ability to have more than one Session Handler.  This is useful if you session creation and teardown\nhas multiple steps that you want to keep in separate objects.\n\nTo set the execution order of the Session Handlers you may choose to add the function `getOrder()` to your Session Handler.\n`getOrder()` should return the numerical value of the position within the exection order for the Session Handler that has\nimplemented the function.  If `getOrder()` is not implements, the Session Handler will be added to the execution order\nbased on the order it was loaded. This means that if you only have one Session Handler, implementing getOrder() is not \nrequired.\n\nSkillVC does not required that Session Handlers need to be in exact numerical order. For instance, you can have one\nSession Handler set to order position 1 and the next at 5 to allow some room for future objects.\n\nExample:\n```\nfunction MySessionHandler() {}\n\nMySessionHandler.prototype.getOrder = function() {\n\treturn 3;\n}\n```\n```\nfunction MyOtherSessionHandler() {}\n\nMyOtherSessionHandler.prototype.getOrder = function() {\n\treturn 1;\n}\n```\n\nIn the above example, SkillVC would execute `MyOtherSessionHandler` before `MySessionHandler`\n\n### Filters\n-----\nFilters in SkillVC are similar to Servlet Filters in the Java world.  They are objects that can be registered and executed\nbefore and after the execution of an Intent Handler.  Filter are very handy for things such as database connection setup\nand teardown, post manipulation of Intent Handler results, or other functionality you wish to execute regardless of the\nintent that Alexa is invoking.\n\nFilters following a loose [Intercepting Filter Pattern](https://en.wikipedia.org/wiki/Intercepting_filter_pattern)\nand can execute before and/or after an Intent Handler has been executed and can implement any (or all) \nof the following functions:\n* `executePre(svContext)` - Called before an Intent Handler is executed\n* `executePreOnError(svContext)` - Called before an Intent Handler is executed and an error occurred\n* `executePost(svContext)` - Called after an Intent Handler as executed\n* `executePostOnError(svContext)` - Called after an Intent Handler is executed and an error occurred\n\n**callback**\nAs Filters could be preforming async operations, the use of a callback is required to tell SkillVC to continue\nwith its execution flow.  The callback to be used can be accessed in `svContext.filterChainCallback` and has two methods:\n* `success` - used if the Filter was successful\n* `failure` - used if the Filter had an error or wants to report some other type of issue\n\nExample:\n```\nfunction DBSetupFilter() {}\n\nDBSetupFilter.prototype.executePre = function(svContext) {\n\t// do what is required to setup the connect\n\t// place it in the context for IntentHandlers (or other objects) to use\n\tsvContext.session.myDbConn = the db.\n\n\t// continue the chain so SkillVC can execute the next step\n\tsvContext.filterChainCallback.success();\n}\n\nDBSetupFilter.prototype.executePost = function(svContext) {\n\t//shutdown the db conn\n\tsvContext.session.myDbConn = null;\n\n\t// continue the chain so SkillVC can execute the next step\n\tsvContext.filterChainCallback.success();\n}\n\n```\n#### Ordering of execution\nSkillVC supports the ability to have more than one Filter.  This is useful if you want to have filters to have distinct\nfunctionality.  \n\nTo set the execution order of the Filters you may choose to add the function `getOrder()` to your Filter.\n`getOrder()` should return the numerical value of the position within the exection order for the Filter that has\nimplemented the function.  If `getOrder()` is not implements, the Filter will be added to the execution order\nbased on the order it was loaded. This means that if you only have one Filter, implementing getOrder() is not \nrequired.\n\nSkillVC does not required that Filter need to be in exact numerical order. For instance, you can have one\nFilter set to order position 1 and the next at 5 to allow some room for future objects.\n\nExample:\n```\nfunction MyFilter() {}\n\nMyFilter.prototype.getOrder = function() {\n\treturn 3;\n}\n```\n```\nfunction MyOtherFilter() {}\n\nMyOtherFilter.prototype.getOrder = function() {\n\treturn 1;\n}\n```\n\n### Advanced Configuration\n-----\nComing soon, if someone asks for it\n\n## Example\n-----\n\n### Hello World\nThe following example (which shows that SkillVC may be overkill for simple skills) demonstrated what is required\nfor a simple hello world skill in SkillVC.  The following example uses CoC to make things as simple as possible.\n\n**/responses/hello.json**\n```\n{\n \t\"outputSpeech\": {\n        \"text\": \"Hello {{name}}! How are you?\"\n    }\n}\n```\n\n**/intents/HelloIntent.js**\n```\nfunction HelloIntentHandler() { \n}\n\nHelloIntentHandler.prototype.handleIntent = function(svContext) {\n\tsvContext.callback.success(\n\t\tsvContext.appConfig.responseManager.getResponse('hello').renderTell(\n\t\t\t{ 'name' : 'Sloan'}\n\t\t)\n\t);\n}\n\nmodule.exports = HelloIntentHandler;\n```\n\n**/index.js**\n```\nvar skillVC = require('skillvc').factory.createfromDirectory();\n\nexports.handler = function(event, context) {\n\tSkillVC.handler(event, context);\n}\n```\n\nIn your intents definition in developer.amazon.com:\n```\n{\n  \"intents\": [\n    { \"intent\": \"HelloIntent\"}\n   ]\n}\n```\n\n## License\n-----\nSkillVC is copyright (c) 2016-present Sloan Seaman <sloan@pobox.com>.\n\nSkillVC is free software, licensed under the [Apache License, Version 2.0](https://www.apache.org/licenses/LICENSE-2.0).",
  "readmeFilename": "README.md",
  "gitHead": "effaaee1ef4821bf23f25aa7824a777072ec9513",
  "homepage": "https://github.com/sseaman/skillVC#readme",
  "_id": "skillvc@0.2.0",
  "_shasum": "e75a143422c04bb10f005b66457c3ca294278033",
  "_from": "skillvc@latest"
}
